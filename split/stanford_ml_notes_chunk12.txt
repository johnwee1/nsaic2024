r, and
in some other literature means the generalization gap.

4e.g., larger than the intrinsic noise level of the data in regression problems.

8.1 Bias-variance tradeoﬀ

115

Figure 8.1: A running example of training and test dataset for this section.

As an illustrating example, we consider the following training dataset and
test dataset, which are also shown in Figure 8.1. The training inputs x(i)’s are
randomly chosen and the outputs y(i) are generated by y(i) = h(cid:63)(x(i)) + ξ(i)
where the function h(cid:63)(·) is a quadratic function and is shown in Figure 8.1
as the solid line, and ξ(i) is the a observation noise assumed to be generated
from ∼ N (0, σ2). A test example (x, y) also has the same input-output
relationship y = h(cid:63)(x) + ξ where ξ ∼ N (0, σ2). It’s impossible to predict the
noise ξ, and therefore essentially our goal is to recover the function h(cid:63)(·).

We will consider the test error of learning various types of models. When
talking about linear regression, we discussed the problem of whether to ﬁt
a “simple” model such as the linear “y = θ0 + θ1x,” or a more “complex”
model such as the polynomial “y = θ0 + θ1x + · · · θ5x5.”

We start with ﬁtting a linear model, as shown in Figure 8.2. The best
ﬁtted linear model cannot predict y from x accurately even on the training
dataset, let alone on the test dataset. This is because the true relationship
between y and x is not linear—any linear model is far away from the true
function h(cid:63)(·). As a result, the training error is large and this is a typical
situation of underﬁtting.

0.00.20.40.60.81.0x0.00.51.01.5ytraining datasettraining dataground truth h*0.00.20.40.60.81.0x0.00.51.01.5ytest datasettest dataground truth h*116

Figure 8.2: The best ﬁt linear model has large training and test errors.

The issue cannot be mitigated with more training examples—even with
a very large amount of, or even inﬁnite training examples, the best ﬁtted
linear model is still inaccurate and fails to capture the structure of the data
(Figure 8.3). Even if the noise is not present in the training data, the issue
still occurs (Figure 8.4). Therefore, the fundamental bottleneck here is the
linear model family’s inability to capture the structure in the data—linear
models cannot represent the true quadratic function h(cid:63)—, but not the lack of
the data. Informally, we deﬁne the bias of a model to be the test error even
if we were to ﬁt it to a very (say, inﬁnitely) large training dataset. Thus, in
this case, the linear model suﬀers from large bias, and underﬁts (i.e., fails to
capture structure exhibited by) the data.

Figure 8.3: The best ﬁt linear
model on a much larger dataset
still has a large training error.

Figure 8.4: The best ﬁt linear
model on a noiseless dataset also
has a large training/test error.

Next, we ﬁt a 5th-degree polynomial to the data. Figure 8.5 shows that
it fails to learn a good model either. However, the failure pattern is diﬀerent
from the linear model case. Speciﬁcally, even though the learnt 5th-degree

0.00.20.40.60.81.0x0.00.51.01.5ytraining databest fit linear model0.00.20.40.60.81.0x0.00.51.01.5ytest databest fit linear model0.00.20.40.60.81.0x0.00.51.01.5yfitting linear models on a large datasettraining dataground truth h*best fit linear model0.00.20.40.60.81.0x0.00.51.01.5yfitting linear models on a noiseless datasettraining dataground truth h*best fit linear model117

polynomial did a very good job predicting y(i)’s from x(i)’s for training ex-
amples, it does not work well on test examples (Figure 8.5). In other words,
the model learnt from the training set does not generalize well to other test
examples—the test error is high. Contrary to the behavior of linear models,
the bias of the 5-th degree polynomials is small—if we were to ﬁt a 5-th de-
gree polynomial to an extremely large dataset, the resulting model would be
close to a quadratic function and be accurate (Figure 8.6). This is because
the family of 5-th degree polynomials contains all the quadratic functions
(setting θ5 = θ4 = θ3 = 0 results in a quadratic function), and, therefore,
5-th degree polynomials are in principle capable of capturing the structure
of the data.

Figure 8.5: Best ﬁt 5-th degree polynomial has zero training error, but still
has a large test error and does not recover the the ground truth. This is a
classic situation of overﬁtting.

Figure 8.6: The best ﬁt 5-th degree polynomial on a huge dataset nearly
recovers the ground-truth—suggesting that the culprit in Figure 8.5 is the
variance (or lack of data) but not bias.

The failure of ﬁtting 5-th degree polynomials can be captured by another

0.00.20.40.60.81.0x0.00.51.01.5ytraining databest fit 5-th degree model0.00.20.40.60.81.0x0.00.51.01.5ytest dataground truth h*best fit 5-th degree model0.00.20.40.60.81.0x0.00.51.01.5ytraining databest fit 5-th degree modelground truth h*fitting 5-th degree model on large dataset118

component of the test error, called variance of a model ﬁtting procedure.
Speciﬁcally, when ﬁtting a 5-th degree polynomial as in Figure 8.7, there is a
large risk that we’re ﬁtting patterns in the data that happened to be present
in our small, ﬁnite training set, but that do not reﬂect the wider pattern of
the relationship between x and y. These “spurious” patterns in the training
set are (mostly) due to the observation noise ξ(i), and ﬁtting these spurious
patters results in a model with large test error. In this case, we say the model
has a large variance.

Figure 8.7: The best ﬁt 5-th degree models on three diﬀerent datasets gen-
erated from the same distribution behave quite diﬀerently, suggesting the
existence of a large variance.

The variance can be intuitively (and mathematically, as shown in Sec-
tion 8.1.1) characterized by the amount of variations across models learnt
on multiple diﬀerent training datasets (drawn from the same underlying dis-
tribution). The “spurious patterns” are speciﬁc to the randomness of the
noise (and inputs) in a particular dataset, and thus are diﬀerent across mul-
tiple training datasets. Therefore, overﬁtting to the “spurious patterns” of
multiple datasets should result in very diﬀerent models. Indeed, as shown
in Figure 8.7, the models learned on the three diﬀerent training datasets are
quite diﬀerent, overﬁtting to the “spurious patterns” of each datasets.

Often, there is a tradeoﬀ between bias and variance. If our model is too
“simple” and has very few parameters, then it may have large bias (but small
variance), and it typically may suﬀer from underﬁttng. If it is too “complex”
and has very many parameters, then it may suﬀer from large variance (but
have smaller bias), and thus overﬁtting. See Figure 8.8 for a typical tradeoﬀ
between bias and variance.

0.00.20.40.60.81.0x0.00.51.01.5ytraining databest fit 5-th degree model0.00.20.40.60.81.0x0.00.51.01.5ytraining databest fit 5-th degree model0.00.20.40.60.81.0x0.00.51.01.5ytraining databest fit 5-th degree modelfitting 5-th degree model on different datasets119

Figure 8.8: An illustration of the typical bias-variance tradeoﬀ.

As we will see formally in Section 8.1.1, the test error can be decomposed
as a summation of bias and variance. This means that the test error will
have a convex curve as the model complexity increases, and in practice we
should tune the model complexity to achieve the best tradeoﬀ. For instance,
in the example above, ﬁtting a quadratic function does better than either of
the extremes of a ﬁrst or a 5-th degree polynomial, as shown in Figure 8.9.

Figure 8.9: Best ﬁt quadratic model has small training and test error because
quadratic model achieves a better tradeoﬀ.

Interestingly, the bias-variance tradeoﬀ curves or the test error curves
do not universally follow the shape in Figure 8.8, at least not universally
when the model complexity is simply measured by the number of parameters.
(We will discuss the so-called double descent phenomenon in Section 8.2.)
Nevertheless, the principle of bias-variance tradeoﬀ is perhaps still the ﬁrst
resort when analyzing and predicting the behavior of test errors.

Model ComplexityErrorBias2VarianceTest Error (= Bias2+Variance)Optimal Tradeoff0.00.20.40.60.81.0x0.00.51.01.5ytraining databest fit quadratic model0.00.20.40.60.81.0x0.00.51.01.5ytest databest fit quadratic modelground truth h*8.1.1 A mathematical decomposition (for regression)

To formally state the bias-variance tradeoﬀ for regression problems, we con-
sider the following setup (which is an extension of the beginning paragraph
of Section 8.1).

120

• Draw a training dataset S = {x(i), y(i)}n

i=1 such that y(i) = h(cid:63)(x(i)) + ξ(i)

where ξ(i) ∈ N (0, σ2).

• Train a model on the dataset S, denoted by ˆhS.

• Take a test example (x, y) such that y = h(cid:63)(x) + ξ where ξ ∼ N (0, σ2),
and measure the expected test error (averaged over the random draw of
the training set S and the randomness of ξ)56

MSE(x) = ES,ξ[(y − hS(x))2]

(8.2)

We will decompose the MSE into a bias and variance term. We start by
stating a following simple mathematical tool that will be used twice below.

Claim 8.1.1: Suppose A and B are two independent real random variables
and E[A] = 0. Then, E[(A + B)2] = E[A2] + E[B2].

As a corollary, because a random variable A is independent with a con-

stant c, when E[A] = 0, we have E[(A + c)2] = E[A2] + c2.

The proof of the claim follows from expanding the square: E[(A + B)2] =
E[A2] + E[B2] + 2E[AB] = E[A2] + E[B2]. Here we used the independence to
show that E[AB] = E[A]E[B] = 0.

Using Claim 8.1.1 with A = ξ and B = h(cid:63)(x) − ˆhS(x), we have

MSE(x) = E[(y − hS(x))2] = E[(ξ + (h(cid:63)(x) − hS(x)))2]

(8.3)
= E[ξ2] + E[(h(cid:63)(x) − hS(x))2] (by Claim 8.1.1)
= σ2 + E[(h(cid:63)(x) − hS(x))2]
(8.4)

Then, let’s deﬁne havg(x) = ES[hS(x)] as the “average model”—the model
obtained by drawing an inﬁnite number of datasets, training on them, and
averaging their predictions on x. Note that havg is a hypothetical model for
analytical purposes that can not be obtained in reality (because we don’t

5For simplicity, the test input x is considered to be ﬁxed here, but the same conceptual

message holds when we average over the choice of x’s.

6The subscript under the expectation symbol is to emphasize the variables that are

considered as random by the expectation operation.

121

It turns out that for many cases, havg
have inﬁnite number of datasets).
is (approximately) equal to the the model obtained by training on a single
dataset with inﬁnite samples. Thus, we can also intuitively interpret havg this
way, which is consistent with our intuitive deﬁnition of bias in the previous
subsection.

We can further decompose MSE(x) by letting c = h(cid:63)(x)−havg(x) (which is
a constant that does not depend on the choice of S!) and A = havg(x)−hS(x)
in the corollary part of Claim 8.1.1:

MSE(x) = σ2 + E[(h(cid:63)(x) − hS(x))2]

= σ2 + (h(cid:63)(x) − havg(x))2 + E[(havg − hS(x))2]
=

+ (h(cid:63)(x) − havg(x))2
(cid:123)(cid:122)
(cid:125)
(cid:44) bias2

(cid:124)

+ var(hS(x))
(cid:125)
(cid:123)(cid:122)
(cid:44) variance

(cid:124)

σ2
(cid:124)(cid:123)(cid:122)(cid:125)
unavoidable

(8.5)
(8.6)
(8.7)

We call the second term the bias (square) and the third term the variance. As
discussed before, the bias captures the part of the error that are introduced
due to the lack of expressivity of the model. Recall that havg can be thought
of as the best possible model learned even with inﬁnite data. Thus, the bias is
not due to the lack of data, but is rather caused by that the family of models
fundamentally cannot approximate the h(cid:63). For example, in the illustrating
example in Figure 8.2, because any linear model cannot approximate the
true quadratic function h(cid:63), neither can havg, and thus the bias term has to
be large.

The variance term captures how the random nature of the ﬁnite dataset
It measures the sensitivity of the
introduces errors in the learned model.
learned model to the randomness in the dataset. It often decreases as the
size of the dataset increases.

There is nothing we can do about the ﬁrst term σ2 as we can not predict

the noise ξ by deﬁnition.

Finally, we note that the bias-variance decomposition for classiﬁcation
is much less clear than for regression problems. There have been several
proposals, but there is as yet no agreement on what is the “right” and/or
the most useful formalism.

8.2 The double descent phenomenon

Model-wise double descent. Recent works have demonstrated that the
test error can present a “double descent” phenomenon in a range of machine

122

learning models including linear models and deep neural networks.7 The
conventional wisdom, as discussed in Section 8.1, is that as we increase the
model complexity, the test error ﬁrst decreases and then increases, as illus-
trated in Figure 8.8. However, in many cases, we empirically observe that
the test error can have a second descent—it ﬁrst decreases, then increases
to a peak around when the model size is large enough to ﬁt all the training
data very well, and then decreases again in the so-called overparameterized
regime, where the number of parameters is larger than the number of data
points. See Figure 8.10 for an illustration of the typical curves of test errors
against model complexity (measured by the number of parameters). To some
extent, the overparameterized regime with the second descent is considered as
new to the machine learning community—partly because lightly-regularized,
overparameterized models are only extensively used in the deep learning era.
A practical implication of the phenomenon is that one should not hold back
from scaling into and experimenting with over-parametrized models because
the test error may well decrease again to a level even smaller than the previ-
ous lowest point. Actually, in many cases, larger overparameterized models
always lead to a better test performance (meaning there won’t be a second
ascent after the second descent).

Figure 8.10: A typical model-wise double descent phenomenon. As the num-
ber of parameters increases, the test error ﬁrst decreases when the number of
parameters is smaller than the training data. Then in the overparameterized
regime, the test error decreases again.

7The discovery of the phenomenon perhaps dates back to Opper [1995, 2001], and has

been recently popularized by Belkin et al. [2020], Hastie et al. [2019], etc.

# parameterstesterrortypicallywhen # parametersis sufficient to fit the dataclassical regime:bias-variance tradeoffmodern regime:over-parameterization123

Sample-wise double descent. A priori, we would expect that more
training examples always lead to smaller test errors—more samples give
strictly more information for the algorithm to learn from. However, recent
work [Nakkiran, 2019] observes that the test error is not monotonically de-
creasing as we increase the sample size. Instead, as shown in Figure 8.11, the
test error decreases, and then increases and peaks around when the number
of examples (denoted by n) is similar to the number of parameters (denoted
by d), and then decreases again. We refer to this as the sample-wise dou-
ble descent phenomenon. To some extent, sample-wise double descent and
model-wise double descent are essentially describing similar phenomena—the
test error is peaked when n ≈ d.

Explanation and mitigation strategy. The sample-wise double descent,
or, in particular, the peak of test error at n ≈ d, suggests that the exi