 you have a training
set with three examples x(1), x(2), x(3). The ï¬rst-layer activations for each
example are as follows:

z[1](1) = W [1]x(1) + b[1]
z[1](2) = W [1]x(2) + b[1]
z[1](3) = W [1]x(3) + b[1]

Note the diï¬€erence between square brackets [Â·], which refer to the layer num-
ber, and parenthesis (Â·), which refer to the training example number.
In-
tuitively, one would implement this using a for loop. It turns out, we can
vectorize these operations as well. First, deï¬ne:

ï£®

ï£°

X =

|

|

|
x(1) x(2) x(3)
|

|

|

ï£¹
ï£» âˆˆ RdÃ—3

(7.81)

Note that we are stacking training examples in columns and not rows. We
can then combine this into a single uniï¬ed formulation:

ï£®

ï£°

Z [1] =

|

|

|
z[1](1) z[1](2) z[1](3)
|

|

|

ï£¹
ï£» = W [1]X + b[1]

(7.82)

You may notice that we are attempting to add b[1] âˆˆ R4Ã—1 to W [1]X âˆˆ
R4Ã—3. Strictly following the rules of linear algebra, this is not allowed. In
practice however, this addition is performed using broadcasting. We create
an intermediate Ëœb[1] âˆˆ R4Ã—3:

Ëœb[1] =

ï£®

ï£°

|
b[1]
|

|
b[1]
|

ï£¹

ï£»

|
b[1]
|

(7.83)

We can then perform the computation: Z [1] = W [1]X + Ëœb[1]. Often times, it
is not necessary to explicitly construct Ëœb[1]. By inspecting the dimensions in
(7.82), you can assume b[1] âˆˆ R4Ã—1 is correctly broadcast to W [1]X âˆˆ R4Ã—3.

The matricization approach as above can easily generalize to multiple

layers, with one subtlety though, as discussed below.

111

Complications/Subtlety in the Implementation. All the deep learn-
ing packages or implementations put the data points in the rows of a data
matrix. (If the data point itself is a matrix or tensor, then the data are con-
centrated along the zero-th dimension.) However, most of the deep learning
papers use a similar notation to these notes where the data points are treated
as column vectors.8 There is a simple conversion to deal with the mismatch:
in the implementation, all the columns become row vectors, row vectors be-
come column vectors, all the matrices are transposed, and the orders of the
matrix multiplications are ï¬‚ipped. In the example above, using the row ma-
jor convention, the data matrix is X âˆˆ R3Ã—d, the ï¬rst layer weight matrix
has dimensionality d Ã— m (instead of m Ã— d as in the two layer neural net
section), and the bias vector b[1] âˆˆ R1Ã—m. The computation for the hidden
activation becomes

Z [1] = XW [1] + b[1] âˆˆ R3Ã—m

(7.84)

8The instructor suspects that this is mostly because in mathematics we naturally mul-

tiply a matrix to a vector on the left hand side.

Part III

Generalization and
regularization

112

Chapter 8

Generalization

This chapter discusses tools to analyze and understand the generaliza-
i.e, their performances on unseen test
tion of machine learning models,
examples. Recall that for supervised learning problems, given a train-
ing dataset {(x(i), y(i))}n
i=1, we typically learn a model hÎ¸ by minimizing a
loss/cost function J(Î¸), which encourages hÎ¸ to ï¬t the data. E.g., when
the loss function is the least square loss (aka mean squared error), we have
J(Î¸) = 1
i=1(y(i) âˆ’ hÎ¸(x(i)))2. This loss function for training purposes is
n
oftentimes referred to as the training loss/error/cost.

(cid:80)n

However, minimizing the training loss is not our ultimate goalâ€”it is
merely our approach towards the goal of learning a predictive model. The
most important evaluation metric of a model is the loss on unseen test exam-
ples, which is oftentimes referred to as the test error. Formally, we sample a
test example (x, y) from the so-called test distribution D, and measure the
modelâ€™s error on it, by, e.g., the mean squared error, (hÎ¸(x) âˆ’ y)2. The ex-
pected loss/error over the randomness of the test example is called the test
loss/error,1

L(Î¸) = E(x,y)âˆ¼D[(y âˆ’ hÎ¸(x))2]

(8.1)

Note that the measurement of the error involves computing the expectation,
and in practice, it can be approximated by the average error on many sampled
test examples, which are referred to as the test dataset. Note that the key
diï¬€erence here between training and test datasets is that the test examples

1In theoretical and statistical literature, we oftentimes call the uniform distribution
over the training set {(x(i), y(i))}n
i=1, denoted by (cid:98)D, an empirical distribution, and call
D the population distribution. Partly because of this, the training loss is also referred
to as the empirical loss/risk/error, and the test loss is also referred to as the population
loss/risk/error.

113

114

are unseen, in the sense that the training procedure has not used the test
examples. In classical statistical learning settings, the training examples are
also drawn from the same distribution as the test distribution D, but still
the test examples are unseen by the learning procedure whereas the training
examples are seen.2

Because of this key diï¬€erence between training and test datasets, even
if they are both drawn from the same distribution D, the test error is not
necessarily always close to the training error.3 As a result, successfully min-
imizing the training error may not always lead to a small test error. We
typically say the model overï¬ts the data if the model predicts accurately on
the training dataset but doesnâ€™t generalize well to other test examples, that
is, if the training error is small but the test error is large. We say the model
underï¬ts the data if the training error is relatively large4 (and in this case,
typically the test error is also relatively large.)

This chapter studies how the test error is inï¬‚uenced by the learning pro-
cedure, especially the choice of model parameterizations. We will decompose
the test error into â€œbiasâ€ and â€œvarianceâ€ terms and study how each of them is
aï¬€ected by the choice of model parameterizations and their tradeoï¬€s. Using
the bias-variance tradeoï¬€, we will discuss when overï¬tting and underï¬tting
will occur and be avoided. We will also discuss the double descent phe-
nomenon in Section 8.2 and some classical theoretical results in Section 8.3.

2These days, researchers have increasingly been more interested in the setting with

â€œdomain shiftâ€, that is, the training distribution and test distribution are diï¬€erent.

3the diï¬€erence between test error and training error is often referred to as the gener-
alization gap. The term generalization error in some literature means the test error, and
in some other literature means the generalization gap.

4e.g., larger than the intrinsic noise level of the data in regression problems.

8.1 Bias-variance tradeoï¬€

115

Figure 8.1: A running example of training and test dataset for this section.

As an illustrating example, we consider the following training dataset and
test dataset, which are also shown in Figure 8.1. The training inputs x(i)â€™s are
randomly chosen and the outputs y(i) are generated by y(i) = h(cid:63)(x(i)) + Î¾(i)
where the function h(cid:63)(Â·) is a quadratic function and is shown in Figure 8.1
as the solid line, and Î¾(i) is the a observation noise assumed to be generated
from âˆ¼ N (0, Ïƒ2). A test example (x, y) also has the same input-output
relationship y = h(cid:63)(x) + Î¾ where Î¾ âˆ¼ N (0, Ïƒ2). Itâ€™s impossible to predict the
noise Î¾, and therefore essentially our goal is to recover the function h(cid:63)(Â·).

We will consider the test error of learning various types of models. When
talking about linear regression, we discussed the problem of whether to ï¬t
a â€œsimpleâ€ model such as the linear â€œy = Î¸0 + Î¸1x,â€ or a more â€œcomplexâ€
model such as the polynomial â€œy = Î¸0 + Î¸1x + Â· Â· Â· Î¸5x5.â€

We start with ï¬tting a linear model, as shown in Figure 8.2. The best
ï¬tted linear model cannot predict y from x accurately even on the training
dataset, let alone on the test dataset. This is because the true relationship
between y and x is not linearâ€”any linear model is far away from the true
function h(cid:63)(Â·). As a result, the training error is large and this is a typical
situation of underï¬tting.

0.00.20.40.60.81.0x0.00.51.01.5ytraining datasettraining dataground truth h*0.00.20.40.60.81.0x0.00.51.01.5ytest datasettest dataground truth h*116

Figure 8.2: The best ï¬t linear model has large training and test errors.

The issue cannot be mitigated with more training examplesâ€”even with
a very large amount of, or even inï¬nite training examples, the best ï¬tted
linear model is still inaccurate and fails to capture the structure of the data
(Figure 8.3). Even if the noise is not present in the training data, the issue
still occurs (Figure 8.4). Therefore, the fundamental bottleneck here is the
linear model familyâ€™s inability to capture the structure in the dataâ€”linear
models cannot represent the true quadratic function h(cid:63)â€”, but not the lack of
the data. Informally, we deï¬ne the bias of a model to be the test error even
if we were to ï¬t it to a very (say, inï¬nitely) large training dataset. Thus, in
this case, the linear model suï¬€ers from large bias, and underï¬ts (i.e., fails to
capture structure exhibited by) the data.

Figure 8.3: The best ï¬t linear
model on a much larger dataset
still has a large training error.

Figure 8.4: The best ï¬t linear
model on a noiseless dataset also
has a large training/test error.

Next, we ï¬t a 5th-degree polynomial to the data. Figure 8.5 shows that
it fails to learn a good model either. However, the failure pattern is diï¬€erent
from the linear model case. Speciï¬cally, even though the learnt 5th-degree

0.00.20.40.60.81.0x0.00.51.01.5ytraining databest fit linear model0.00.20.40.60.81.0x0.00.51.01.5ytest databest fit linear model0.00.20.40.60.81.0x0.00.51.01.5yfitting linear models on a large datasettraining dataground truth h*best fit linear model0.00.20.40.60.81.0x0.00.51.01.5yfitting linear models on a noiseless datasettraining dataground truth h*best fit linear model117

polynomial did a very good job predicting y(i)â€™s from x(i)â€™s for training ex-
amples, it does not work well on test examples (Figure 8.5). In other words,
the model learnt from the training set does not generalize well to other test
examplesâ€”the test error is high. Contrary to the behavior of linear models,
the bias of the 5-th degree polynomials is smallâ€”if we were to ï¬t a 5-th de-
gree polynomial to an extremely large dataset, the resulting model would be
close to a quadratic function and be accurate (Figure 8.6). This is because
the family of 5-th degree polynomials contains all the quadratic functions
(setting Î¸5 = Î¸4 = Î¸3 = 0 results in a quadratic function), and, therefore,
5-th degree polynomials are in principle capable of capturing the structure
of the data.

Figure 8.5: Best ï¬t 5-th degree polynomial has zero training error, but still
has a large test error and does not recover the the ground truth. This is a
classic situation of overï¬tting.

Figure 8.6: The best ï¬t 5-th degree polynomial on a huge dataset nearly
recovers the ground-truthâ€”suggesting that the culprit in Figure 8.5 is the
variance (or lack of data) but not bias.

The failure of ï¬tting 5-th degree polynomials can be captured by another

0.00.20.40.60.81.0x0.00.51.01.5ytraining databest fit 5-th degree model0.00.20.40.60.81.0x0.00.51.01.5ytest dataground truth h*best fit 5-th degree model0.00.20.40.60.81.0x0.00.51.01.5ytraining databest fit 5-th degree modelground truth h*fitting 5-th degree model on large dataset118

component of the test error, called variance of a model ï¬tting procedure.
Speciï¬cally, when ï¬tting a 5-th degree polynomial as in Figure 8.7, there is a
large risk that weâ€™re ï¬tting patterns in the data that happened to be present
in our small, ï¬nite training set, but that do not reï¬‚ect the wider pattern of
the relationship between x and y. These â€œspuriousâ€ patterns in the training
set are (mostly) due to the observation noise Î¾(i), and ï¬tting these spurious
patters results in a model with large test error. In this case, we say the model
has a large variance.

Figure 8.7: The best ï¬t 5-th degree models on three diï¬€erent datasets gen-
erated from the same distribution behave quite diï¬€erently, suggesting the
existence of a large variance.

The variance can be intuitively (and mathematically, as shown in Sec-
tion 8.1.1) characterized by the amount of variations across models learnt
on multiple diï¬€erent training datasets (drawn from the same underlying dis-
tribution). The â€œspurious patternsâ€ are speciï¬c to the randomness of the
noise (and inputs) in a particular dataset, and thus are diï¬€erent across mul-
tiple training datasets. Therefore, overï¬tting to the â€œspurious patternsâ€ of
multiple datasets should result in very diï¬€erent models. Indeed, as shown
in Figure 8.7, the models learned on the three diï¬€erent training datasets are
quite diï¬€erent, overï¬tting to the â€œspurious patternsâ€ of each datasets.

Often, there is a tradeoï¬€ between bias and variance. If our model is too
â€œsimpleâ€ and has very few parameters, then it may have large bias (but small
variance), and it typically may suï¬€er from underï¬ttng. If it is too â€œcomplexâ€
and has very many parameters, then it may suï¬€er from large variance (but
have smaller bias), and thus overï¬tting. See Figure 8.8 for a typical tradeoï¬€
between bias and variance.

0.00.20.40.60.81.0x0.00.51.01.5ytraining databest fit 5-th degree model0.00.20.40.60.81.0x0.00.51.01.5ytraining databest fit 5-th degree model0.00.20.40.60.81.0x0.00.51.01.5ytraining databest fit 5-th degree modelfitting 5-th degree model on different datasets119

Figure 8.8: An illustration of the typical bias-variance tradeoï¬€.

As we will see formally in Section 8.1.1, the test error can be decomposed
as a summation of bias and variance. This means that the test error will
have a convex curve as the model complexity increases, and in practice we
should tune the model complexity to achieve the best tradeoï¬€. For instance,
in the example above, ï¬tting a quadratic function does better than either of
the extremes of a ï¬rst or a 5-th degree polynomial, as shown in Figure 8.9.

Figure 8.9: Best ï¬t quadratic model has small training and test error because
quadratic model achieves a better tradeoï¬€.

Interestingly, the bias-variance tradeoï¬€ curves or the test error curves
do not universally follow the shape in Figure 8.8, at least not universally
when the model complexity is simply measured by the number of parameters.
(We will discuss the so-called double descent phenomenon in Section 8.2.)
Nevertheless, the principle of bias-variance tradeoï¬€ is perhaps still the ï¬rst
resort when analyzing and predicting the behavior of test errors.

Model ComplexityErrorBias2VarianceTest Error (= Bias2+Variance)Optimal Tradeoff0.00.20.40.60.81.0x0.00.51.01.5ytraining databest fit quadratic model0.00.20.40.60.81.0x0.00.51.01.5ytest databest fit quadratic modelground truth h*8.1.1 A mathematical decomposition (for regression)

To formally state the bias-variance tradeoï¬€ for regression problems, we con-
sider the following setup (which is an extension of the beginning paragraph
of Section 8.1).

120

â€¢ Draw a training dataset S = {x(i), y(i)}n

i=1 such that y(i) = h(cid:63)(x(i)) + Î¾(i)

where Î¾(i) âˆˆ N (0, Ïƒ2).

â€¢ Train a model on the dataset S, denoted by Ë†hS.

â€¢ Take a test example (x, y) such that y = h(cid:63)(x) + Î¾ where Î¾ âˆ¼ N (0, Ïƒ2),
and measure the expected test error (averag