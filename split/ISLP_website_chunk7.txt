d
means that when they are passed into the function, they can be referred
to by name (in any order).3 By default, this function will generate random
normal variable(s) with mean (loc) 0 and standard deviation (scale) 1; furthermore, a single random variable will be generated unless the argument
to size is changed.
We now generate 50 independent random variables from a N (0, 1) distribution.
In [28]: x = np.random.normal(size =50)
x
Out[28]: array ([ -1.19 ,
-0.35,
-0.77,
1.7 ,
-0.3 ,
0.79,
-0.09,

0.41, 0.9 ,
1.16, 0.79,
-2.12, 0.38,
-0.95, 0.56,
-1.36, 0.92,
-0.46, 2.19,
0.7 ])

-0.44,
-0.97,
-1.22,
0.35,
-0.31,
-0.27,

-0.9 , -0.38, 0.13, 1.87,
-1.21, 0.06, -1.62, -0.6 ,
-0.06, -1.97, -1.74, -0.56,
0.87, 0.88, -1.66, -0.32,
1.28, -1.94, 1.07, 0.07,
-0.64, 0.85, 0.13, 0.46,

We create an array y by adding an independent N (50, 1) random variable
to each element of x.
In [29]: y = x + np.random.normal(loc=50, scale=1, size =50)

The np.corrcoef() function computes the correlation matrix between x and
np.corrcoef()
y. The off-diagonal elements give the correlation between x and y.
In [30]: np.corrcoef(x, y)
Out[30]: array ([[1. , 0.69] ,
[0.69 , 1. ]])

If you’re following along in your own Jupyter notebook, then you probably
noticed that you got a different set of results when you ran the past few
commands. In particular, each time we call np.random.normal(), we will get
a different answer, as shown in the following example.
In [31]: print(np.random.normal(scale=5, size =2))
print(np.random.normal(scale=5, size =2))
Out[31]: [4.28 2.59]
[4.62 -2.54]

In order to ensure that our code provides exactly the same results each
time it is run, we can set a random seed using the np.random.default_rng()
random seed
function. This function takes an arbitrary, user-specified integer argument. np.random.
If we set a random seed before generating random data, then re-running default_rng()
our code will yield the same results. The object rng has essentially all the
3 Python also uses positional arguments. Positional arguments do not need to use a
keyword. To see an example, type in np.sum?. We see that a is a positional argument,
i.e. this function assumes that the first unnamed argument that it receives is the array
to be summed. By contrast, axis and dtype are keyword arguments: the position in
which these arguments are entered into np.sum() does not matter.

2.3 Lab: Introduction to Python

47

random number generating methods found in np.random. Hence, to generate
normal data we use rng.normal().
In [32]: rng = np.random.default_rng (1303)
print(rng.normal(scale=5, size =2))
rng2 = np.random.default_rng (1303)
print(rng2.normal(scale=5, size =2))
Out[32]: [4.09
[4.09

-1.07 ]
-1.07 ]

Throughout the labs in this book, we use np.random.default_rng() whenever we perform calculations involving random quantities within numpy. In
principle, this should enable the reader to exactly reproduce the stated
results. However, as new versions of numpy become available, it is possible
that some small discrepancies may occur between the output in the labs
and the output from numpy.
The np.mean(), np.var(), and np.std() functions can be used to compute
np.mean()
the mean, variance, and standard deviation of arrays. These functions are
np.var()
also available as methods on the arrays.
np.std()

In [33]: rng = np.random.default_rng (3)
y = rng.standard_normal (10)
np.mean(y), y.mean ()
Out[33]: (-0.11, -0.11)
In [34]: np.var(y), y.var(), np.mean ((y - y.mean ())**2)
Out[34]: (2.72 , 2.72, 2.72)

Notice that by default np.var() divides by the sample size n rather than
n − 1; see the ddof argument in np.var?.

In [35]: np.sqrt(np.var(y)), np.std(y)
Out[35]: (1.65 , 1.65)

The np.mean(), np.var(), and np.std() functions can also be applied to the
rows and columns of a matrix. To see this, we construct a 10 × 3 matrix of
N (0, 1) random variables, and consider computing its row sums.
In [36]: X = rng.standard_normal ((10, 3))
X
Out[36]: array ([[ 0.23,
[-0.67,
[ 0.48,
[-0.2 ,
[ 0.55,
[ 0.54,
[-0.24,
[-0.29,
[ 0.09,
[ 1.02,

-0.35,
-1.06,
-0.24,
0.02,
-0.51,
1.94,
1. ,
0.88,
0.67,
-0.96,

-0.28],
-0.39],
0.96] ,
1.55] ,
-0.18],
-0.27],
-0.89],
0.58] ,
-2.83],
-1.67]])

48

2. Statistical Learning

Since arrays are row-major ordered, the first axis, i.e. axis=0, refers to its
rows. We pass this argument into the mean() method for the object X.

.mean()

In [37]: X.mean(axis =0)
Out[37]: array ([0.15 , 0.14, -0.34])

The following yields the same result.
In [38]: X.mean (0)
Out[38]: array ([0.15 , 0.14, -0.34])

2.3.4 Graphics
In Python, common practice is to use the library matplotlib for graphics. matplotlib
However, since Python was not written with data analysis in mind, the notion of plotting is not intrinsic to the language. We will use the subplots()
function from matplotlib.pyplot to create a figure and the axes onto which
we plot our data. For many more examples of how to make plots in Python,
readers are encouraged to visit matplotlib.org/stable/gallery/.
In matplotlib, a plot consists of a figure and one or more axes. You can
figure
think of the figure as the blank canvas upon which one or more plots will axes
be displayed: it is the entire plotting window. The axes contain important
information about each plot, such as its x- and y-axis labels, title, and
more. (Note that in matplotlib, the word axes is not the plural of axis: a
plot’s axes contains much more information than just the x-axis and the
y-axis.)
We begin by importing the subplots() function from matplotlib. We
subplots()
use this function throughout when creating figures. The function returns
a tuple of length two: a figure object as well as the relevant axes object.
We will typically pass figsize as a keyword argument. Having created our
axes, we attempt our first plot using its plot() method. To learn more
.plot()
about it, type ax.plot?.
In [39]: from matplotlib.pyplot import subplots
fig , ax = subplots(figsize =(8, 8))
x = rng.standard_normal (100)
y = rng.standard_normal (100)
ax.plot(x, y);

We pause here to note that we have unpacked the tuple of length two returned by subplots() into the two distinct variables fig and ax. Unpacking
is typically preferred to the following equivalent but slightly more verbose
code:
In [40]: output = subplots(figsize =(8, 8))
fig = output [0]
ax = output [1]

We see that our earlier cell produced a line plot, which is the default.
To create a scatterplot, we provide an additional argument to ax.plot(),
indicating that circles should be displayed.

2.3 Lab: Introduction to Python

49

In [41]: fig , ax = subplots(figsize =(8, 8))
ax.plot(x, y, 'o');

Different values of this additional argument can be used to produce different
colored lines as well as different linestyles.
As an alternative, we could use the ax.scatter() function to create a
.scatter()
scatterplot.
In [42]: fig , ax = subplots(figsize =(8, 8))
ax.scatter(x, y, marker='o');

Notice that in the code blocks above, we have ended the last line with a
semicolon. This prevents ax.plot(x, y) from printing text to the notebook.
However, it does not prevent a plot from being produced. If we omit the
trailing semi-colon, then we obtain the following output:
In [43]: fig , ax = subplots(figsize =(8, 8))
ax.scatter(x, y, marker='o')
Out[43]: <matplotlib.collections.PathCollection at 0x7fb3d9c8f310 >
Figure (432 x288)

In what follows, we will use trailing semicolons whenever the text that
would be output is not germane to the discussion at hand.
To label our plot, we make use of the set_xlabel(), set_ylabel(), and
.set_xlabel()
set_title() methods of ax.
.set_ylabel()

In [44]: fig , ax = subplots(figsize =(8, 8))
ax.scatter(x, y, marker='o')
ax.set_xlabel("this is the x-axis")
ax.set_ylabel("this is the y-axis")
ax.set_title("Plot of X vs Y");

Having access to the figure object fig itself means that we can go in and
change some aspects and then redisplay it. Here, we change the size from
(8, 8) to (12, 3).
fig.set_size_inches (12 ,3)
fig

Occasionally we will want to create several plots within a figure. This
can be achieved by passing additional arguments to subplots(). Below, we
create a 2 × 3 grid of plots in a figure of size determined by the figsize
argument. In such situations, there is often a relationship between the
axes in the plots. For example, all plots may have a common x-axis. The
subplots() function can automatically handle this situation when passed
the keyword argument sharex=True. The axes object below is an array
pointing to different plots in the figure.
In [45]: fig , axes = subplots(nrows=2,
ncols=3,
figsize =(15, 5))

We now produce a scatter plot with 'o' in the second column of the first
row and a scatter plot with '+' in the third column of the second row.

.set_title()

50

2. Statistical Learning

In [46]: axes [0 ,1]. plot(x, y, 'o')
axes [1 ,2]. scatter(x, y, marker='+')
fig

Type subplots? to learn more about subplots().
To save the output of fig, we call its savefig() method. The argument
.savefig()
dpi is the dots per inch, used to determine how large the figure will be in
pixels.
In [47]: fig.savefig("Figure.png", dpi =400)
fig.savefig("Figure.pdf", dpi =200);

We can continue to modify fig using step-by-step updates; for example,
we can modify the range of the x-axis, re-save the figure, and even re-display
it.
In [48]: axes [0 ,1]. set_xlim ([ -1 ,1])
fig.savefig("Figure_updated.jpg")
fig

We now create some more sophisticated plots. The ax.contour() method
.contour()
produces a contour plot in order to represent three-dimensional data, similar
contour plot
to a topographical map. It takes three arguments:
• A vector of x values (the first dimension),
• A vector of y values (the second dimension), and
• A matrix whose elements correspond to the z value (the third dimension) for each pair of (x,y) coordinates.
To create x and y, we’ll use the command np.linspace(a, b, n), which
np.linspace()
returns a vector of n numbers starting at a and ending at b.
In [49]: fig , ax = subplots(figsize =(8, 8))
x = np.linspace(-np.pi , np.pi , 50)
y = x
f = np.multiply.outer(np.cos(y), 1 / (1 + x**2))
ax.contour(x, y, f);

We can increase the resolution by adding more levels to the image.
In [50]: fig , ax = subplots(figsize =(8, 8))
ax.contour(x, y, f, levels =45);

To fine-tune the output of the ax.contour() function, take a look at the
help file by typing ?plt.contour.
The ax.imshow() method is similar to ax.contour(), except that it pro.imshow()
duces a color-coded plot whose colors depend on the z value. This is known
as a heatmap, and is sometimes used to plot temperature in weather foreheatmap
casts.
In [51]: fig , ax = subplots(figsize =(8, 8))
ax.imshow(f);

2.3 Lab: Introduction to Python

2.3.5

51

Sequences and Slice Notation

As seen above, the function np.linspace() can be used to create a sequence
of numbers.
In [52]: seq1 = np.linspace (0, 10, 11)
seq1
Out[52]: array ([ 0.,

1.,

2.,

3.,

4.,

5.,

6.,

7.,

8.,

9., 10.])

The function np.arange() returns a sequence of numbers spaced out by
np.arange()
step. If step is not specified, then a default value of 1 is used. Let’s create
a sequence that starts at 0 and ends at 10.
In [53]: seq2 = np.arange (0, 10)
seq2
Out[53]: array ([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

Why isn’t 10 output above? This has to do with slice notation in Python.
slice
Slice notation is used to index sequences such as lists, tuples and arrays.
Suppose we want to retrieve the fourth through sixth (inclusive) entries of
a string. We obtain a slice of the string using the indexing notation [3:6].
In [54]: "hello world"[3:6]
Out[54]: 'lo '

In the code block above, the notation 3:6 is shorthand for slice(3,6) when
used inside [].
In [55]: "hello world"[slice (3,6)]
Out[55]: 'lo '

You might have expected slice(3,6) to output the fourth through seventh
characters in the text string (recalling that Python begins its indexing at
zero), but instead it output the fourth through sixth. This also explains
why the earlier np.arange(0, 10) command output only the integers from
0 to 9. See the documentation slice? for useful options in creating slices.

2.3.6

Indexing Data

To begin, we create a two-dimensional numpy array.
In [56]: A = np.array(np.arange (16)).reshape ((4, 4))
A
Out[56]: array ([[ 0, 1, 2, 3],
[ 4, 5, 6, 7],
[ 8, 9, 10, 11],
[12, 13, 14, 15]])

Typing A[1,2] retrieves the element corresponding to the second row and
third column. (As usual, Python indexes from 0.)

52

2. Statistical Learning

In [57]: A[1,2]
Out[57]: 6

The first number after the open-bracket symbol [ refers to the row, and
the second number refers to the column.
Indexing Rows, Columns, and Submatrices
To select multiple rows at a time, we can pass in a list specifying our
selection. For instance, [1,3] will retrieve the second and fourth rows:
In [58]: A[[1 ,3]]
Out[58]: array ([[ 4, 5, 6, 7],
[12, 13, 14, 15]])

To select the first and third columns, we pass in [0,2] as the second argument in the square brackets. In this case we need to supply the first
argument : which selects all rows.
In [59]: A[: ,[0 ,2]]
Out[59]: array ([[ 0, 2],
[ 4, 6],
[ 8, 10],
[12, 14]])

Now, suppose that we want to select the submatrix made up of the second
and fourth rows as well as the first and third columns. This is where indexing gets slightly tricky. It is natural to try to use lists to retrieve the rows
and columns:
In [60]: A[[1 ,3] ,[0 ,2]]
Out[60]: array ([ 4, 14])

Oops — what happened? We got a one-dimensional array of length two
identical to
In [61]: np.array ([A[1,0],A[3 ,2]])
Out[61]: array ([ 4, 14])

Similarly, the following code fails to extract the submatrix comprised of
the second and fourth rows and the first, third, and fourth columns:
In [62]: A[[1 ,3] ,[0 ,2 ,3]]
IndexError: shape mismatch: indexing arrays could not be broadcast
together with shapes (2,) (3,)

2.3 Lab: Introduction to Python

53

We can see what has gone wrong here. When supplied with two indexing
lists, the numpy interpretation is that these provide pairs of i, j indices for
a series of entries. That is why the pair of lists must have the same length.
However, that was not our intent, since we are looking for a submatrix.
One easy way to do this is as follows. We first create a submatrix by
subsetting the rows of A, and then on the fly we make a further submatrix
by subsetting its columns.
In [63]: A[[1 ,3]][: ,[0 ,2]]
Out[63]: array ([[ 4, 6],
[12, 14]])

There are more efficient ways of achieving the same result.
The convenience function np.ix_() allows us to extract a submatrix using
convenience
lists, by creating an intermediate mesh object.
function
np.ix_()

In [64]: idx = np.ix_ ([1 ,3] ,[0 ,2 ,3])
A[idx]

mesh

Out[64]: array ([[ 4, 6, 7],
[12, 14, 15]])

Alternatively, we can subset matrices efficiently using slices. The slice

1:4:2 captures the second and fourth items of a sequence, while the slice
0:3:2 captures the first and third items (the third element in a slice se-

quence is the step size).
In [65]: A[1:4:2 ,0:3:2]
Out[65]: array ([[ 4, 6],
[12, 14]])

Why are we able to retrieve a submatrix directly using slices but not using
lists? Its because they are different Python types, and are treated differently
by numpy. Slices can be used to extract objects from arbitrary sequences,
such as strings, lists, and tuples, while the use of lists for indexing is more
limited.
Boolean Indexing
In numpy, a Boolean is a type that equals either True or False (als