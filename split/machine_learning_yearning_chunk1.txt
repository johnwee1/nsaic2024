m different distributions. Luck, rather than skill, will have a 
greater impact on your performance on such benchmarks compared to if the dev and test 
sets come from the same distribution. It is an important research problem to develop 
learning algorithms that are trained on one distribution and generalize well to another. But if 
your goal is to make progress on a specific machine learning application rather than make 
research progress, I  recommend trying to choose dev and test sets that are drawn from the 
same distribution. This will make your team more efficient.  

Page 18



Andrew Ng 

 
 
 
 
 
 
7 How large do the dev/test sets need to be? 

The dev set should be large enough to detect differences between algorithms that you are 
trying out. For example, if classifier A has an accuracy of 90.0% and classifier B has an 
accuracy of 90.1%, then a dev set of 100 examples would not be able to detect this 0.1% 
difference. Compared to other machine learning problems I’ve seen, a 100 example dev set is 
small. Dev sets with sizes from 1,000 to 10,000 examples are common. With 10,000 
2
examples, you will have a good chance of detecting an improvement of 0.1%.  

For mature and important applications—for example, advertising, web search, and product 
recommendations—I have also seen teams that are highly motivated to eke out even a 0.01% 
improvement, since it has a direct impact on the company’s profits. In this case, the dev set 
could be much larger than 10,000, in order to detect even smaller improvements.  

How about the size of the test set? It should be large enough to give high confidence in the 
overall performance of your system. One popular heuristic had been to use 30% of your data 
for your test set. This works well when you have a modest number of examples—say 100 to 
10,000 examples. But in the era of big data where we now have machine learning problems 
with sometimes more than a billion examples, the fraction of data allocated to dev/test sets 
has been shrinking, even as the absolute number of examples in the dev/test sets has been 
growing. There is no need to have excessively large dev/test sets beyond what is needed to 
evaluate the performance of your algorithms. 

2 In theory, one could also test if a change to an algorithm makes a statistically significant difference 
on the dev set. In practice, most teams don’t bother with this (unless they are publishing academic 
research papers), and I usually do not find statistical significance tests useful for measuring interim 
progress.  

Page 19



Andrew Ng 

 
 
 
8 Establish a single-number evaluation metric 
for your team to optimize  

Classification accuracy is an example of a 
your classifier on the dev set (or test set), and get back a single number about what fraction 
of examples it classified correctly. According to this metric, if classifier A obtains 97% 
accuracy, and classifier B obtains 90% accuracy, then we judge classifier A to be superior. 

single-number evaluation metric

: You run 

In contrast, Precision and Recall  is not a single-number evaluation metric: It gives two 
numbers for assessing your classifier. Having multiple-number evaluation metrics makes it 
harder to compare algorithms. Suppose your algorithms perform as follows:   

3

Classifier 

Precision 

Recall 

A 

B 

95% 

98% 

90% 

85% 

Here, neither classifier is obviously superior, so it doesn’t immediately guide you toward 
picking one. 

Classifier 

Precision 

Recall 

F1 score 

A 

95% 

90% 

92.4% 

During development, your team will try a lot of ideas about algorithm architecture, model 
parameters, choice of features, etc. Having a 
accuracy allows you to sort all your models according to their performance on this metric, 
and quickly decide what is working best.  

single-number evaluation metric

 such as 

If you really care about both Precision and Recall, I recommend using one of the standard 
ways to combine them into a single number. For example, one could take the average of 
precision and recall, to end up with a single number.  Alternatively, you can compute the “F1 

3 The Precision of a cat classifier is the fraction of images in the dev (or test) set it labeled as cats that 
really are cats. Its Recall is the percentage of all cat images in the dev (or test) set that it correctly 
labeled as a cat. There is often a tradeoff between having high precision and high recall.  

Page 20



Andrew Ng 

 
 
​
​
 
 
 
 
​
​
score,” which is a modified way of computing their average, and works better than simply 
taking the mean.  4

Classifier 

Precision 

Recall 

F1 score 

A 

B 

95% 

98% 

90% 

85% 

92.4% 

91.0% 

Having a single-number evaluation metric speeds up your ability to make a decision when 
you are selecting among a large number of classifiers. It gives a clear preference ranking 
among all of them, and therefore a clear direction for progress.  

As a final example, suppose you are separately tracking the accuracy of your cat classifier in 
four key markets: (i) US, (ii) China, (iii) India, and (iv) Other. This gives four metrics. By 
taking an average or weighted average of these four numbers, you end up with a single 
number metric. Taking an average or weighted average is one of the most common ways to 
combine multiple metrics into one.  

4 If you want to learn more about the F1 score, see 
. It is the 
“harmonic mean” between Precision and Recall, and is calculated as 2/((1/Precision)+(1/Recall)).  

https://en.wikipedia.org/wiki/F1_score

Page 21



Andrew Ng 

 
 
 
 
 
 
 
​
​
9 Optimizing and satisficing metrics  

Here’s another way to combine multiple evaluation metrics.  

Suppose you care about both the accuracy and the running time of a learning algorithm. You 
need to choose from these three classifiers:  

Classifier 

Accuracy 

Running time 

A 

B 

C 

90% 

92% 

95% 

80ms 

95ms 

1,500ms 

It seems unnatural to derive a single metric by putting accuracy and running time into a 
single formula, such as:  

Accuracy - 0.5*RunningTime 

Here’s what you can do instead: First, define what is an “acceptable” running time. Lets say 
anything that runs in 100ms is acceptable. Then, maximize accuracy, subject to your 
classifier meeting the running time criteria. Here, running time is a “satisficing 
metric”—your classifier just has to be “good enough” on this metric, in the sense that it 
should take at most 100ms. Accuracy is the “optimizing metric.” 

If you are trading off N different criteria, such as binary file size of the model (which is 
important for mobile apps, since users don’t want to download large apps), running time, 
and accuracy, you might consider setting N-1 of the criteria as “satisficing” metrics. I.e., you 
simply require that they meet a certain value. Then define the final one as the “optimizing” 
metric. For example, set a threshold for what is acceptable for binary file size and running 
time, and try to optimize accuracy given those constraints. 

As a final example, suppose you are building a hardware device that uses a microphone to 
listen for the user saying a particular “wakeword,” that then causes the system to wake up. 
Examples include Amazon Echo listening for “Alexa”; Apple Siri listening for “Hey Siri”; 
Android listening for “Okay Google”; and Baidu apps listening for “Hello Baidu.” You care 
about both the false positive rate—the frequency with which the system wakes up even when 
no one said the wakeword—as well as the false negative rate—how often it fails to wake up 
when someone says the wakeword. One reasonable goal for the performance of this system is 

Page 22



Andrew Ng 

 
 
 
to minimize the false negative rate (optimizing metric), subject to there being no more than 
one false positive every 24 hours of operation (satisficing metric).  

Once your team is aligned on the evaluation metric to optimize, they will be able to make 
faster progress.  

Page 23



Andrew Ng 

 
 
 
 
 
 
 
 
 
 
 
 
 
10 Having a dev set and metric speeds up 
iterations 

It is very difficult to know in advance what approach will work best for a new problem. Even 
experienced machine learning researchers will usually try out many dozens of ideas before 
they discover something satisfactory. When building a machine learning system, I will often:  

1. Start off with some 

idea

 on how to build the system.  

2. Implement the idea in 

code

. 

3. Carry out an 

experiment

 which tells me how well the idea worked. (Usually my first few 
ideas don’t work!) Based on these learnings, go back to generate more ideas, and keep on 
iterating.  

This is an iterative process. The faster you can go round this loop, the faster you will make 
progress. This is why having dev/test sets and a metric are important: Each time you try an 
idea, measuring your idea’s performance on the dev set lets you quickly decide if you’re 
heading in the right direction.  

In contrast, suppose you don’t have a specific dev set and metric. So each time your team 
develops a new cat classifier, you have to incorporate it into your app, and play with the app 
for a few hours to get a sense of whether the new classifier is an improvement. This would be 
incredibly slow! Also, if your team improves the classifier’s accuracy from 95.0% to 95.1%, 
you might not be able to detect that 0.1% improvement from playing with the app. Yet a lot 
of progress in your system will be made by gradually accumulating dozens of these 0.1% 
improvements. Having a dev set and metric allows you to very quickly detect which ideas are 
successfully giving you small (or large) improvements, and therefore lets you quickly decide 
what ideas to keep refining, and which ones to discard.  

Page 24



Andrew Ng 

 
 
​
​
​
​
​
​
 
 
11 When to change dev/test sets and metrics  

When starting out on a new project, I try to quickly choose dev/test sets, since this gives the 
team a well-defined target to aim for.  

I typically ask my teams to come up with an initial dev/test set and an initial metric in less 
than one week—rarely longer. It is better to come up with something imperfect and get going 
quickly, rather than overthink this. But this one week timeline does not apply to mature 
applications. For example, anti-spam is a mature deep learning application. I have seen 
teams working on already-mature systems spend months to acquire even better dev/test 
sets.  

If you later realize that your initial dev/test set or metric missed the mark, by all means 
change them quickly. For example, if your dev set + metric ranks classifier A above classifier 
B, but your team thinks that classifier B is actually superior for your product, then this might 
be a sign that you need to change your dev/test sets or your evaluation metric.  

There are three main possible causes of the dev set/metric incorrectly rating classifier A 
higher:  

1. The actual distribution you need to do well on is different from the dev/test sets. 

Suppose your initial dev/test set had mainly pictures of adult cats. You ship your cat app, 
and find that users are uploading a lot more kitten images than expected. So, the dev/test set 
distribution is not representative of the actual distribution you need to do well on. In this 
case, update your dev/test sets to be more representative.  

Page 25



Andrew Ng 

 
 
 
2. You have overfit to the dev set. 

The process of repeatedly evaluating ideas on the dev set causes your algorithm to gradually 
“overfit” to the dev set. When you are done developing, you will evaluate your system on the 
test set. If you find that your dev set performance is much better than your test set 
performance, it is a sign that you have overfit to the dev set. In this case, get a fresh dev set.  

If you need to track your team’s progress, you can also evaluate your system regularly—say 
once per week or once per month—on the test set. But do not use the test set to make any 
decisions regarding the algorithm, including whether to roll back to the previous week’s 
system. If you do so, you will start to overfit to the test set, and can no longer count on it to 
give a completely unbiased estimate of your system’s performance (which you would need if 
you’re publishing research papers, or perhaps using this metric to make important business 
decisions).  

3. The metric is measuring something other than what the project needs to optimize. 

Suppose that for your cat application, your metric is classification accuracy. This metric 
currently ranks classifier A as superior to classifier B. But suppose you try out both 
algorithms, and find classifier A is allowing occasional pornographic images to slip through. 
Even though classifier A is more accurate, the bad impression left by the occasional 
pornographic image means its performance is unacceptable. What do you do?  

Here, the metric is failing to identify the fact that Algorithm B is in fact better than 
Algorithm A for your product. So, you can no longer trust the metric to pick the best 
algorithm. It is time to change evaluation metrics. For example, you can change the metric to 
heavily penalize letting through pornographic images.  I would strongly recommend picking 
a new metric and using the new metric to explicitly define a new goal for the team, rather 
than proceeding for too long without a trusted metric and reverting to manually choosing 
among classifiers.   

It is quite common to change dev/test sets or evaluation metrics during a project. Having an 
initial dev/test set and metric helps you iterate quickly. If you ever find that the dev/test sets 
or metric are no longer pointing your team in the right direction, it’s not a big deal! Just 
change them and make sure your team knows about the new direction.   

Page 26



Andrew Ng 

 
 
 
 
 
12 Takeaways: Setting up development and 
test sets 

• Choose dev and test sets from a distribution that reflects what data you expect to get in 
the future and want to do well on. This may not be the same as your training data’s 
distribution.  

• Choose dev and test sets from the same distribution if possible.  

• Choose a single-number evaluation metric for your team to optimize. If there are multiple 

goals that you care about, consider combining them into a single formula (such as 
averaging multiple error metrics) or defining satisficing and optimizing metrics.  

• Machine learning is a highly iterative process: You may try many dozens of ideas before 

finding one that you’re satisfied with.  

• Having dev/test sets and a single-number evaluation metric helps you quickly evaluate 

algorithms, and therefore iterate faster.  

• When starting out on a brand new application, try to establish dev/test sets and a metric 
quickly, say in less than a week. It might be okay to take longer on mature applications.  

• The old heuristic of a 70%/30% train/test split does not apply for problems where you 

have a lot of data; the dev and test sets can be much less than 30% of the data.  

• Your dev set should be large enough to detect meaningful changes in the accuracy of your 
algorithm, but not necessarily much larger. Your test set should be big enough to give you 
a confident estimate of the final performance of your system.  

•

If your dev set and metric are no longer pointing your team in the right direction, quickly 
change them: (i) If you had overfit the dev set, get more dev set data. (ii)