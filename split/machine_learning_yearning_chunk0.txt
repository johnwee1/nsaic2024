 
Machine Learning Yearning is a  
deeplearning.ai project. 

© 2018 Andrew Ng. All Rights Reserved. 

Page 2



Andrew Ng 

 
Table of Contents 

1 Why Machine Learning Strategy 

2 How to use this book to help your team 

3 Prerequisites and Notation 

4 Scale drives machine learning progress 

5 Your development and test sets 

6 Your dev and test sets should come from the same distribution 

7 How large do the dev/test sets need to be? 

8 Establish a single-number evaluation metric for your team to optimize 

9 Optimizing and satisficing metrics 

10 Having a dev set and metric speeds up iterations 

11 When to change dev/test sets and metrics 

12 Takeaways: Setting up development and test sets 

13 Build your first system quickly, then iterate 

14 Error analysis: Look at dev set examples to evaluate ideas 

15 Evaluating multiple ideas in parallel during error analysis 

16 Cleaning up mislabeled dev and test set examples 

17 If you have a large dev set, split it into two subsets, only one of which you look at 

18 How big should the Eyeball and Blackbox dev sets be? 

19 Takeaways: Basic error analysis 

20 Bias and Variance: The two big sources of error 

21 Examples of Bias and Variance 

22 Comparing to the optimal error rate 

23 Addressing Bias and Variance 

24 Bias vs. Variance tradeoff 

25 Techniques for reducing avoidable bias 

Page 3



Andrew Ng 

 
 
26 Error analysis on the training set 

27 Techniques for reducing variance 

28 Diagnosing bias and variance: Learning curves 

29 Plotting training error 

30 Interpreting learning curves: High bias 

31 Interpreting learning curves: Other cases 

32 Plotting learning curves 

33 Why we compare to human-level performance 

34 How to define human-level performance 

35 Surpassing human-level performance 

36 When you should train and test on different distributions 

37 How to decide whether to use all your data 

38 How to decide whether to include inconsistent data 

39 Weighting data 

40 Generalizing from the training set to the dev set 

41 Identifying Bias, Variance, and Data Mismatch Errors 

42 Addressing data mismatch 

43 Artificial data synthesis 

44 The Optimization Verification test 

45 General form of Optimization Verification test 

46 Reinforcement learning example 

47 The rise of end-to-end learning 

48 More end-to-end learning examples 

49 Pros and cons of end-to-end learning 

50 Choosing pipeline components: Data availability 

51 Choosing pipeline components: Task simplicity 

Page 4



Andrew Ng 

 
52 Directly learning rich outputs 

53 Error analysis by parts 

54 Attributing error to one part 

55 General case of error attribution 

56 Error analysis by parts and comparison to human-level performance 

57 Spotting a flawed ML pipeline 

58 Building a superhero team - Get your teammates to read this 

Page 5



Andrew Ng 

 
 
 
 
 
 
 
 
 
 
1 Why Machine Learning Strategy 

Machine learning is the foundation of countless important applications, including web 
search, email anti-spam, speech recognition, product recommendations, and more. I assume 
that you or your team is working on a machine learning application, and that you want to 
make rapid progress. This book will help you do so.  

Example: Building a cat picture startup  
Say you’re building a startup that will provide an endless stream of cat pictures to cat lovers. 

You use a neural network to build a computer vision system for detecting cats in pictures. 

But tragically, your learning algorithm’s accuracy is not yet good enough. You are under 
tremendous pressure to improve your cat detector. What do you do?  

Your team has a lot of ideas, such as: 

• Get more data: Collect more pictures of cats.  

• Collect a more diverse training set. For example, pictures of cats in unusual positions; cats 

with unusual coloration; pictures shot with a variety of camera settings; ….  

• Train the algorithm longer, by running more gradient descent iterations. 

• Try a bigger neural network, with more layers/hidden units/parameters.  

Page 6



Andrew Ng 

 
 
• Try a smaller neural network. 

• Try adding regularization (such as L2 regularization).  

• Change the neural network architecture (activation function, number of hidden units, etc.) 

• …  

If you choose well among these possible directions, you’ll build the leading cat picture 
platform, and lead your company to success. If you choose poorly, you might waste months. 
How do you proceed?  

This book will tell you how. Most machine learning problems leave clues that tell you what’s 
useful to try, and what’s not useful to try. Learning to read those clues will save you months 
or years of development time.  

Page 7



Andrew Ng 

 
 
 
 
 
 
2 How to use this book to help your team 

After finishing this book, you will have a deep understanding of how to set technical 
direction for a machine learning project.  

But your teammates might not understand why you’re recommending a particular direction. 
Perhaps you want your team to define a single-number evaluation metric, but they aren’t 
convinced. How do you persuade them?   

That’s why I made the chapters short: So that you can print them out and get your 
teammates to read just the 1-2 pages you need them to know.  

A few changes in prioritization can have a huge effect on your team’s productivity. By helping 
your team with a few such changes, I hope that you can become the superhero of your team!  

Page 8



Andrew Ng 

 
 
 
 
 
 
 
3 Prerequisites and Notation 

If you have taken a Machine Learning course such as my machine learning MOOC on 
Coursera, or if you have experience applying supervised learning, you will be able to 
understand this text.  

supervised learning

I assume you are familiar with 
to y, using labeled training examples (x,y). Supervised learning algorithms include linear 
regression, logistic regression, and neural networks. There are many forms of machine 
learning, but the majority of Machine Learning’s practical value today comes from 
supervised learning.  

: learning a function that maps from x 

I will frequently refer to neural networks (also known as “deep learning”). You’ll only need a 
basic understanding of what they are to follow this text.  

If you are not familiar with the concepts mentioned here, watch the first three weeks of 
videos in the Machine Learning course on Coursera at 

http://ml-class.org 

Page 9



Andrew Ng 

 
 
​
​
​
 
 
4 Scale drives machine learning progress 

Many of the ideas of deep learning (neural networks) have been around for decades. Why are 
these ideas taking off now?  

Two of the biggest drivers of recent progress have been: 

• Data availability.

 People are now spending more time on digital devices (laptops, mobile 

devices). Their digital activities generate huge amounts of data that we can feed to our 
learning algorithms.  

• Computational scale. 

We started just a few years ago to be able to train neural 
networks that are big enough to take advantage of the huge datasets we now have.  

In detail, even as you accumulate more data, usually the performance of older learning 
algorithms, such as logistic regression, “plateaus.” This means its learning curve “flattens 
out,” and the algorithm stops improving even as you give it more data:  

It was as if the older algorithms didn’t know what to do with all the data we now have.  

If you train a small neutral network (NN) on the same supervised learning task, you might 
get slightly better performance:   

Page 10



Andrew Ng 

 
 
​
​
 
 
 
 
 
 
 
 
 
 
 
 
Here, by “Small NN” we mean a neural network with only a small number of hidden 
units/layers/parameters. Finally, if you train larger and larger neural networks, you can 
1
obtain even better performance:  

Thus, you obtain the best performance when you (i) Train a very large neural network, so 
that you are on the green curve above; (ii) Have a huge amount of data.  

Many other details such as neural network architecture are also important, and there has 
been much innovation here. But one of the more reliable ways to improve an algorithm’s 
performance today is still to (i) train a bigger network and (ii) get more data.  

1 This diagram shows NNs doing better in the regime of small datasets. This effect is less consistent 
than the effect of NNs doing well in the regime of huge datasets. In the small data regime, depending 
on how the features are hand-engineered, traditional algorithms may or may not do better. For 
example, if you have 20 training examples, it might not matter much whether you use logistic 
regression or a neural network; the hand-engineering of features will have a bigger effect than the 
choice of algorithm. But if you have 1 million examples, I would favor the neural network.  

Page 11



Andrew Ng 

 
 
 
The process of how to accomplish (i) and (ii) are surprisingly complex. This book will discuss 
the details at length. We will start with general strategies that are useful for both traditional 
learning algorithms and neural networks, and build up to the most modern strategies for 
building deep learning systems. 

Page 12



Andrew Ng 

 
 
Setting up 
development and 
test sets 

Page 13



Andrew Ng 

 
 
 
 
 
 
 
 
 
 
 
 
5 Your development and test sets 

Let’s return to our earlier cat pictures example: You run a mobile app, and users are 
uploading pictures of many different things to your app. You want to automatically find the 
cat pictures.  

Your team gets a large training set by downloading pictures of cats (positive examples) and 
non-cats (negative examples) off of different websites. They split the dataset 70%/30% into 
training and test sets. Using this data, they build a cat detector that works well on the 
training and test sets.  

But when you deploy this classifier into the mobile app, you find that the performance is 
really poor!  

What happened?  

You figure out that the pictures users are uploading have a different look than the website 
images that make up your training set: Users are uploading pictures taken with mobile 
phones, which tend to be lower resolution, blurrier, and poorly lit. Since your training/test 
sets were made of website images, your algorithm did not generalize well to the actual 
distribution you care about: mobile phone pictures.  

Before the modern era of big data, it was a common rule in machine learning to use a 
random 70%/30% split to form your training and test sets. This practice can work, but it’s a 
bad idea in more and more applications where the training distribution (website images in 

Page 14



Andrew Ng 

 
 
 
 
      
 
our example above) is different from the distribution you ultimately care about (mobile 
phone images). 

We usually define: 

• Training set

 — Which you run your learning algorithm on. 

• Dev (development) set

 — Which you use to tune parameters, select features, and 

make other decisions regarding the learning algorithm. Sometimes also called the 
hold-out cross validation set

.  

• Test set

 — which you use to evaluate the performance of the algorithm, but not to make 

any decisions regarding what learning algorithm or parameters to use.  

Once you define a dev set (development set) and test set, your team will try a lot of ideas, 
such as different learning algorithm parameters, to see what works best. The dev and test 
sets allow your team to quickly see how well your algorithm is doing.  

In other words, 
the most important changes to make to the machine learning system

the purpose of the dev and test sets are to direct your team toward 

.  

So, you should do the following:  

Choose dev and test sets to reflect data you expect to get in the future 
and want to do well on.  

In other words, your test set should not simply be 30% of the available data, especially if you 
expect your future data (mobile phone images) to be different in nature from your training 
set (website images).  

If you have not yet launched your mobile app, you might not have any users yet, and thus 
might not be able to get data that accurately reflects what you have to do well on in the 
future. But you might still try to approximate this. For example, ask your friends to take 
mobile phone pictures of cats and send them to you. Once your app is launched, you can 
update your dev/test sets using actual user data.  

If you really don’t have any way of getting data that approximates what you expect to get in 
the future, perhaps you can start by using website images. But you should be aware of the 
risk of this leading to a system that doesn’t generalize well.  

It requires judgment to decide how much to invest in developing great dev and test sets. But 
don’t assume your training distribution is the same as your test distribution. Try to pick test 

Page 15



Andrew Ng 

 
​
​
​
​
​
​
examples that reflect what you ultimately want to perform well on, rather than whatever data 
you happen to have for training.  

Page 16



Andrew Ng 

 
 
 
 
6 Your dev and test sets should come from the 
same distribution 

You have your cat app image data segmented into four regions, based on your largest 
markets: (i) US, (ii) China, (iii) India, and (iv) Other. To come up with a dev set and a test 
set, say we put US and India in the dev set; China and Other in the test set. In other words, 
we can randomly assign two of these segments to the dev set, and the other two to the test 
set, right?  

Once you define the dev and test sets, your team will be focused on improving dev set 
performance. Thus, the dev set should reflect the task you want to improve on the most: To 
do well on all four geographies, and not only two.  

There is a second problem with having different dev and test set distributions: There is a 
chance that your team will build something that works well on the dev set, only to find that it 
does poorly on the test set. I’ve seen this result in much frustration and wasted effort. Avoid 
letting this happen to you.  

As an example, suppose your team develops a system that works well on the dev set but not 
the test set. If your dev and test sets had come from the same distribution, then you would 
have a very clear diagnosis of what went wrong: You have overfit the dev set. The obvious 
cure is to get more dev set data.  

But if the dev and test sets come from different distributions, then your options are less 
clear. Several things could have gone wrong:  

1. You had overfit to the dev set.  

2. The test set is harder than the dev set. So your algorithm might be doing as well as could 

be expected, and no further significant improvement is possible.  

Page 17



Andrew Ng 

 
3. The test set is not necessarily harder, but just different, from the dev set. So what works 
well on the dev set just does not work well on the test set. In this case, a lot of your work 
to improve dev set performance might be wasted effort.   

Working on machine learning applications is hard enough. Having mismatched dev and test 
sets introduces additional uncertainty about whether improving on the dev set distribution 
also improves test set performance. Having mismatched dev and test sets makes it harder to 
figure out what is and isn’t working, and thus makes it harder to prioritize what to work on.  

If you are working on a 3rd party benchmark problem, their creator might have specified dev 
and test sets that come fro