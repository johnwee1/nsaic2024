ize parameter of
1
k . In this book we denote the step-size parameter by the symbol Î± or, more
generally, by Î±t(a). We sometimes use the informal shorthand Î± = 1
k to refer
to this case, leaving the dependence of k on the action implicit.

2.4 Tracking a Nonstationary Problem

The averaging methods discussed so far are appropriate in a stationary envi-
ronment, but not if the bandit is changing over time. As noted earlier, we
often encounter reinforcement learning problems that are eï¬€ectively nonsta-
tionary. In such cases it makes sense to weight recent rewards more heavily
than long-past ones. One of the most popular ways of doing this is to use a
constant step-size parameter. For example, the incremental update rule (2.3)
for updating an average Qk of the k

1 past rewards is modiï¬ed to be

âˆ’

Qk+1 = Qk + Î±

Qk

,

(2.5)

Rk âˆ’
(cid:104)

(cid:105)

where the step-size parameter Î±
âˆˆ
being a weighted average of past rewards and the initial estimate Q1:

(0, 1]1 is constant. This results in Qk+1

Qk+1 = Qk + Î±

Qk

(cid:104)
= Î±Rk + (1
= Î±Rk + (1
= Î±Rk + (1
= Î±Rk + (1

Rk âˆ’
âˆ’
âˆ’
âˆ’
âˆ’

(cid:105)
Î±)Qk
Î±) [Î±Rk
Î±)Î±Rk
Î±)Î±Rk
âˆ’
+ (1
k

âˆ’

Â· Â· Â·
Î±)kQ1 +

= (1

âˆ’

1]

1 + (1
âˆ’
1 + (1
1 + (1
Î±)k

Î±)Qk
âˆ’
âˆ’
Î±)2Qk
1
âˆ’
âˆ’
Î±)2Î±Rk
âˆ’
âˆ’
1Î±R1 + (1
âˆ’

âˆ’

2 +

Î±)kQ1

âˆ’

Î±(1

âˆ’

Î±)k

iRi.
âˆ’

i=1
(cid:88)

We call this a weighted average because the sum of the weights is (1

k
i=1 Î±(1
i, given to the reward Ri depends on how many rewards ago, k
âˆ’

i = 1, as you can check yourself. Note that the weight, Î±(1
âˆ’

âˆ’
i, it was

Î±)k

âˆ’

âˆ’

âˆ’

Î±)k
(cid:80)

1The notation (a, b] as a set denotes the real interval between a and b including b but

not including a. Thus, here we are saying that 0 < Î±

1.

â‰¤

(2.6)

Î±)k +

2.5. OPTIMISTIC INITIAL VALUES

39

âˆ’

Î± is less than 1, and thus the weight given to Ri
observed. The quantity 1
decreases as the number of intervening rewards increases. In fact, the weight
Î± = 0, then
decays exponentially according to the exponent on 1
all the weight goes on the very last reward, Rk, because of the convention that
00 = 1.) Accordingly, this is sometimes called an exponential, recency-weighted
average.

Î±. (If 1

âˆ’

âˆ’

Sometimes it is convenient to vary the step-size parameter from step to
step. Let Î±k(a) denote the step-size parameter used to process the reward
received after the kth selection of action a. As we have noted, the choice
Î±k(a) = 1
k results in the sample-average method, which is guaranteed to con-
verge to the true action values by the law of large numbers. But of course
. A well-
convergence is not guaranteed for all choices of the sequence
known result in stochastic approximation theory gives us the conditions re-
quired to assure convergence with probability 1:

Î±k(a)
}
{

âˆ

Î±k(a) =

âˆ

and

âˆ

Î±2

k(a) <

.
âˆ

(cid:88)k=1

(cid:88)k=1
The ï¬rst condition is required to guarantee that the steps are large enough to
eventually overcome any initial conditions or random ï¬‚uctuations. The second
condition guarantees that eventually the steps become small enough to assure
convergence.

(2.7)

Note that both convergence conditions are met for the sample-average case,
Î±k(a) = 1
k , but not for the case of constant step-size parameter, Î±k(a) = Î±. In
the latter case, the second condition is not met, indicating that the estimates
never completely converge but continue to vary in response to the most re-
cently received rewards. As we mentioned above, this is actually desirable in
a nonstationary environment, and problems that are eï¬€ectively nonstationary
In addition, sequences of step-size
are the norm in reinforcement learning.
parameters that meet the conditions (2.7) often converge very slowly or need
considerable tuning in order to obtain a satisfactory convergence rate. Al-
though sequences of step-size parameters that meet these convergence condi-
tions are often used in theoretical work, they are seldom used in applications
and empirical research.

2.5 Optimistic Initial Values

All the methods we have discussed so far are dependent to some extent on
the initial action-value estimates, Q1(a). In the language of statistics, these
methods are biased by their initial estimates. For the sample-average methods,

40

CHAPTER 2. MULTI-ARM BANDITS

Figure 2.2: The eï¬€ect of optimistic initial action-value estimates on the 10-
armed testbed. Both methods used a constant step-size parameter, Î± = 0.1.

the bias disappears once all actions have been selected at least once, but for
methods with constant Î±, the bias is permanent, though decreasing over time
as given by (2.6). In practice, this kind of bias is usually not a problem, and
can sometimes be very helpful. The downside is that the initial estimates
become, in eï¬€ect, a set of parameters that must be picked by the user, if only
to set them all to zero. The upside is that they provide an easy way to supply
some prior knowledge about what level of rewards can be expected.

Initial action values can also be used as a simple way of encouraging ex-
ploration. Suppose that instead of setting the initial action values to zero, as
we did in the 10-armed testbed, we set them all to +5. Recall that the q(a)
in this problem are selected from a normal distribution with mean 0 and vari-
ance 1. An initial estimate of +5 is thus wildly optimistic. But this optimism
encourages action-value methods to explore. Whichever actions are initially
selected, the reward is less than the starting estimates; the learner switches
to other actions, being â€œdisappointedâ€ with the rewards it is receiving. The
result is that all actions are tried several times before the value estimates con-
verge. The system does a fair amount of exploration even if greedy actions are
selected all the time.

Figure 2.2 shows the performance on the 10-armed bandit testbed of a
greedy method using Q1(a) = +5, for all a. For comparison, also shown is an
Îµ-greedy method with Q1(a) = 0. Initially, the optimistic method performs
worse because it explores more, but eventually it performs better because its
exploration decreases with time. We call this technique for encouraging ex-
ploration optimistic initial values. We regard it as a simple trick that can be
quite eï¬€ective on stationary problems, but it is far from being a generally use-
ful approach to encouraging exploration. For example, it is not well suited to

0%20%40%60%80%100%%Optimalaction02004006008001000Playsoptimistic, greedyQ0 = 5,    = 0realistic, !-greedyQ0 = 0,    = 0.111Stepsğœ€ğœ€2.6. UPPER-CONFIDENCE-BOUND ACTION SELECTION

41

nonstationary problems because its drive for exploration is inherently tempo-
rary. If the task changes, creating a renewed need for exploration, this method
cannot help. Indeed, any method that focuses on the initial state in any special
way is unlikely to help with the general nonstationary case. The beginning
of time occurs only once, and thus we should not focus on it too much. This
criticism applies as well to the sample-average methods, which also treat the
beginning of time as a special event, averaging all subsequent rewards with
equal weights. Nevertheless, all of these methods are very simple, and one of
them or some simple combination of them is often adequate in practice. In the
rest of this book we make frequent use of several of these simple exploration
techniques.

2.6 Upper-Conï¬dence-Bound Action Selection

Exploration is needed because the estimates of the action values are uncertain.
The greedy actions are those that look best at present, but some of the other
actions may actually be better. Îµ-greedy action selection forces the non-greedy
actions to be tried, but indiscriminately, with no preference for those that are
nearly greedy or particularly uncertain. It would be better to select among
the non-greedy actions according to their potential for actually being optimal,
taking into account both how close their estimates are to being maximal and
the uncertainties in those estimates. One eï¬€ective way of doing this is to select
actions as

At = argmax

a

(cid:34)

Qt(a) + c

ln t
Nt(a) (cid:35)

,

(cid:115)

(2.8)

where ln t denotes the natural logarithm of t (the number that e
2.71828
would have to be raised to in order to equal t), and the number c > 0 controls
the degree of exploration. If Nt(a) = 0, then a is considered to be a maximizing
action.

â‰ˆ

The idea of this upper conï¬dence bound (UCB) action selection is that the
square-root term is a measure of the uncertainty or variance in the estimate
of aâ€™s value. The quantity being maxâ€™ed over is thus a sort of upper bound
on the possible true value of action a, with the c parameter determining the
conï¬dence level. Each time a is selected the uncertainty is presumably reduced;
Nt(a) is incremented and, as it appears in the denominator of the uncertainty
term, the term is decreased. On the other hand, each time an action other a is
selected t is increased; as it appears in the numerator the uncertainty estimate
is increased. The use of the natural logarithm means that the increase gets
smaller over time, but is unbounded; all actions will eventually be selected, but

42

CHAPTER 2. MULTI-ARM BANDITS

Figure 2.3: Average performance of UCB action selection on the 10-armed
testbed. As shown, UCB generally performs better that Îµ-greedy action selec-
tion, except in the ï¬rst n plays, when it selects randomly among the as-yet-
unplayed actions. UCB with c = 1 would perform even better but would not
show the prominent spike in performance on the 11th play. Can you think of
an explanation of this spike?

as time goes by it will be a longer wait, and thus a lower selection frequency,
for actions with a lower value estimate or that have already been selected more
times.

Results with UCB on the 10-armed testbed are shown in Figure 2.3. UCB
will often perform well, as shown here, but is more diï¬ƒcult than Îµ-greedy
to extend beyond bandits to the more general reinforcement learning settings
considered in the rest of this book. One diï¬ƒculty is in dealing with nonsta-
tionary problems; something more complex than the methods presented in
Section 2.4 would be needed. Another diï¬ƒculty is dealing with large state
spaces, particularly function approximation as developed in Part III of this
book. In these more advanced settings there is currently no known practical
way of utilizing the idea of UCB action selection.

2.7 Gradient Bandits

So far in this chapter we have considered methods that estimate action values
and use those estimates to select actions. This is often a good approach,
but it is not the only one possible.
In this section we consider learning a
numerical preference Ht(a) for each action a. The larger the preference, the

ğœ€-greedy  ğœ€ = 0.1UCB  c = 2AveragerewardSteps2.7. GRADIENT BANDITS

43

more often that action is taken, but the preference has no interpretation in
terms of reward. Only the relative preference of one action over another is
important; if we add 1000 to all the preferences there is no aï¬€ect on the action
probabilities, which are determined according to a soft-max distribution (i.e.,
Gibbs or Boltzmann distribution) as follows:

At = a
Pr
{

}

=

eHt(a))
b=1 eHt(b) = Ï€t(a),
n

(2.9)

where here we have also introduced a useful new notation Ï€t(a) for the proba-
bility of taking action a at time t. Initially all preferences are the same (e.g.,
a) so that all actions have an equal probability of being selected.
H1(a) = 0,

(cid:80)

âˆ€

There is a natural learning algorithm for this setting based on the idea
of stochastic gradient ascent. On each step, after selecting the action At and
receiving the reward Rt, the preferences are updated by:

Ï€t(At)

,

and

(2.10)

Ht+1(At) = Ht(At) + Î±
Î±
Ht+1(a) = Ht(a)

Â¯Rt
Rt âˆ’
Â¯Rt
Rt âˆ’
(cid:0)
(cid:0)

1

âˆ’
Ï€t(a),
(cid:1)(cid:0)

a

= At,

(cid:1)

(cid:1)
âˆ’
where Î± > 0 is a step-size parameter, and Â¯Rt âˆˆ
R is the average of all the
rewards up through and including time t, which can be computed incrementally
as described in Section 2.3 (or Section 2.4 if the problem is nonstationary).
The Â¯Rt term serves as a baseline with which the reward is compared. If the
reward is higher than the baseline, then the probability of taking At in the
future is increased, and if the reward is below baseline, then probability is
decreased. The non-selected actions move in the opposite direction.

âˆ€

Figure 2.4 shows results with the gradient-bandit algorithm on a variant
of the 10-armed testbed in which the true expected rewards were selected
according to a normal distribution with a mean of +4 instead of zero (and with
unit variance as before). This shifting up of all the rewards has absolutely no
aï¬€ect on the gradient-bandit algorithm because of the reward baseline term,
which instantaneously adapts to the new level. But if the baseline were omitted
(that is, if Â¯Rt was taken to be constant zero in (2.10)), then performance would
be signiï¬cantly degraded, as shown in the ï¬gure.

One can gain a deeper insight into this algorithm by understanding it as
a stochastic approximation to gradient ascent. In exact gradient ascent, each
preference Ht(a) would be incrementing proportional to the incrementâ€™s eï¬€ect
on performance:

Ht+1(a) = Ht(a) + Î±

âˆ‚ E [Rt]
âˆ‚Ht(a)

,

(2.11)

where the measure of performance here is the expected reward:

E[Rt] =

Ï€t(b)q(b).

(cid:88)b

(cid:54)
44

CHAPTER 2. MULTI-ARM BANDITS

Figure 2.4: Average performance of the gradient-bandit algorithm with and
without a reward baseline on the 10-armed testbed with E[q(a)] = 4.

Of course, it is not possible to implement gradient ascent exactly in our case
because by assumption we do not know the q(b), but in fact the updates of our
algorithm (2.10) are equal to (2.11) in expected value, making the algorithm
an instance of stochastic gradient ascent.

The calculations showing this require only beginning calculus, but take
several steps. If you are mathematically inclined, then you will enjoy the rest
of this section in which we go through these steps. First we take a closer look
at the exact performance gradient:

âˆ‚ E[Rt]
âˆ‚Ht(a)

=

=

=

âˆ‚
âˆ‚Ht(a) (cid:34)

q(b)

(cid:88)b

q(b)

(cid:88)b

(cid:0)

Ï€t(b)q(b)

(cid:35)

(cid:88)b
âˆ‚ Ï€t(b)
âˆ‚Ht(a)

Xt

âˆ’

âˆ‚ Ï€t(b)
âˆ‚Ht(a)

,

(cid:1)

where Xt can be any scalar that does not depend on b. We can include it here
âˆ‚ Ï€t(b)
âˆ‚Ht(a) = 0. As
because the gradient sums to zero over the all the actions,
Ht(a) is changed, some actionsâ€™ probabilities go up and some down, but the
sum of the changes must be zero because the sum of the probabilities must

(cid:80)

b

%OptimalactionStepsÎ± = 0.1100%80%60%40%20%0%Î± = 0.4Î± = 0.1Î± = 0.4without baselinewith baseline025050075010002.7. GRADIENT BANDITS

45

remain one.

âˆ‚ E[Rt]
âˆ‚Ht(a)

=

Ï€t(b)

q(b)

(cid:88)b

(cid:0)

Xt

âˆ’

âˆ‚ Ï€t(b)
âˆ‚Ht(a)

/Ï€t(b)

(cid:1)

The equation is now in the form of an expectation, summing over all possible
values b of the random variable At, then multiplying by the probability of
taking those values. Thus:

âˆ‚ E[Rt]
âˆ‚Ht(a)

= E

q(At)

= E

(cid:20)
(cid:0)

(cid:20)
(cid:0)

Rt âˆ’

âˆ’

Â¯Rt

Xt

âˆ‚ Ï€t(At)
âˆ‚Ht(a)

/Ï€t(At)
(cid:21)

(cid:1)

âˆ‚ Ï€t(At)
âˆ‚Ht(a)

(cid:1)

,

/Ï€t(At)
(cid:21)

where here we have chosen Xt = Â¯Rt and substituted Rt for q(At), which is
permitted because E[Rt] = q(At) and because all the other factors are non-
, where Ia=b
random. Shortly we will establish that âˆ‚ Ï€t(b)
Ï€t(a)
is deï¬ned to be 1 if a = b, else 0. Assuming that for now we have
(cid:1)

Ia=b âˆ’
(cid:0)

âˆ‚Ht(a) = Ï€t(b)

âˆ‚ E[Rt]
âˆ‚Ht(a)

= E

= E

Rt âˆ’
Rt âˆ’

(cid:2)(c