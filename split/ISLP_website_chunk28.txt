, the methods first create a generic classifier without
referring to any data. This classifier is then fit to data with the fit()
method and predictions are always produced with the predict() method.
This pattern of first instantiating the classifier, followed by fitting it, and
then producing predictions is an explicit design choice of sklearn. This
uniformity makes it possible to cleanly copy the classifier so that it can be
fit on different data; e.g. different training sets arising in cross-validation.
This standard pattern also allows for a predictable formation of workflows.

4.7.4

Quadratic Discriminant Analysis

We will now fit a QDA model to the Smarket data. QDA is implemented
via QuadraticDiscriminantAnalysis() in the sklearn package, which we ab- Quadratic
breviate to QDA(). The syntax is very similar to LDA().
Discriminant
In [33]: qda = QDA( store_covariance=True)
qda.fit(X_train , L_train)
Out[33]: QuadraticDiscriminantAnalysis (store_covariance=True)

The QDA() function will again compute means_ and priors_.
In [34]: qda.means_ , qda.priors_
Out[34]: (array ([[ 0.04279022 , 0.03389409] ,
[ -0.03954635 , -0.03132544]]) ,
array ([0.49198397 , 0.50801603]))

The QDA() classifier will estimate one covariance per class. Here is the
estimated covariance in the first class:
In [35]: qda.covariance_ [0]
Out[35]: array ([[ 1.50662277 , -0.03924806] ,
[ -0.03924806 , 1.53559498]])

The output contains the group means. But it does not contain the coefficients of the linear discriminants, because the QDA classifier involves a
quadratic, rather than a linear, function of the predictors. The predict()
function works in exactly the same fashion as for LDA.

Analysis()

182

4. Classification

In [36]: qda_pred = qda.predict(X_test)
confusion_table(qda_pred , L_test)
Out[36]:

Truth
Predicted
Down
Up

Down

Up

30
81

20
121

Interestingly, the QDA predictions are accurate almost 60% of the time,
even though the 2005 data was not used to fit the model.
In [37]: np.mean(qda_pred == L_test)
Out[37]: 0.599

This level of accuracy is quite impressive for stock market data, which
is known to be quite hard to model accurately. This suggests that the
quadratic form assumed by QDA may capture the true relationship more
accurately than the linear forms assumed by LDA and logistic regression.
However, we recommend evaluating this method’s performance on a larger
test set before betting that this approach will consistently beat the market!

4.7.5

Naive Bayes

Next, we fit a naive Bayes model to the Smarket data. The syntax is similar
to that of LDA() and QDA(). By default, this implementation GaussianNB() of
GaussianNB()
the naive Bayes classifier models each quantitative feature using a Gaussian
distribution. However, a kernel density method can also be used to estimate
the distributions.
In [38]: NB = GaussianNB ()
NB.fit(X_train , L_train)
Out[38]: GaussianNB ()

The classes are stored as classes_.
In [39]: NB.classes_
Out[39]: array (['Down ', 'Up'], dtype='<U4')

The class prior probabilities are stored in the class_prior_ attribute.
In [40]: NB.class_prior_
Out[40]: array ([0.49 , 0.51])

The parameters of the features can be found in the theta_ and var_
attributes. The number of rows is equal to the number of classes, while the
number of columns is equal to the number of features. We see below that
the mean for feature Lag1 in the Down class is 0.043.
In [41]: NB.theta_
Out[41]: array ([[ 0.043 , 0.034] ,
[-0.040, -0.031]])

4.7 Lab: Logistic Regression, LDA, QDA, and KNN

183

Its variance is 1.503.
In [42]: NB.var_
Out[42]: array ([[1.503 , 1.532] ,
[1.514 , 1.487]])

How do we know the names of these attributes? We use NB? (or ?NB).
We can easily verify the mean computation:
In [43]: X_train[L_train == 'Down ']. mean ()
Out[43]: Lag1
0.042790
Lag2
0.033894
dtype: float64

Similarly for the variance:
In [44]: X_train[L_train == 'Down '].var(ddof =0)
Out[44]: Lag1
1.503554
Lag2
1.532467
dtype: float64

The GaussianNB() function calculates variances using the 1/n formula.6
Since NB() is a classifier in the sklearn library, making predictions uses the
same syntax as for LDA() and QDA() above.
In [45]: nb_labels = NB.predict(X_test)
confusion_table(nb_labels , L_test)
Out[45]:

Truth
Predicted
Down
Up

Down

Up

29
82

20
121

Naive Bayes performs well on these data, with accurate predictions over
59% of the time. This is slightly worse than QDA, but much better than
LDA.
As for LDA, the predict_proba() method estimates the probability that
each observation belongs to a particular class.
In [46]: NB.predict_proba(X_test)[:5]
Out[46]: array ([[0.4873 ,
[0.4762 ,
[0.4653 ,
[0.4748 ,
[0.4902 ,

4.7.6

0.5127] ,
0.5238] ,
0.5347] ,
0.5252] ,
0.5098]])

K-Nearest Neighbors

We will now perform KNN using the KNeighborsClassifier() function. This KNeighbors

Classifier()

6 There

are!two formulas for computing
the sample variance of n observations
n
1
1 !n
2 and
2
x1 , . . . , x n : n
(x
−
x̄)
(x
i
i=1
i=1 i − x̄) where x̄ is the sample mean.
n−1
In most cases the distinction is not important.

184

4. Classification

function works similarly to the other model-fitting functions that we have
encountered thus far.
As is the case for LDA and QDA, we fit the classifier using the fit
method. New predictions are formed using the predict method of the object
returned by fit().
In [47]: knn1 = KNeighborsClassifier(n_neighbors =1)
knn1.fit(X_train , L_train)
knn1_pred = knn1.predict(X_test)
confusion_table(knn1_pred , L_test)
Out[47]:

Truth
Predicted
Down
Up

Down

Up

43
68

58
83

The results using K = 1 are not very good, since only 50% of the observations are correctly predicted. Of course, it may be that K = 1 results in an
overly-flexible fit to the data.
In [48]: (83+43) /252, np.mean(knn1_pred == L_test)
Out[48]: (0.5, 0.5)

We repeat the analysis below using K = 3.
In [49]: knn3 = KNeighborsClassifier(n_neighbors =3)
knn3_pred = knn3.fit(X_train , L_train).predict(X_test)
np.mean(knn3_pred == L_test)
Out[49]: 0.532

The results have improved slightly. But increasing K further provides no
further improvements. It appears that for these data, and this train/test
split, QDA gives the best results of the methods that we have examined so
far.
KNN does not perform well on the Smarket data, but it often does provide
impressive results. As an example we will apply the KNN approach to the
Caravan data set, which is part of the ISLP library. This data set includes 85
predictors that measure demographic characteristics for 5,822 individuals.
The response variable is Purchase, which indicates whether or not a given
individual purchases a caravan insurance policy. In this data set, only 6%
of people purchased caravan insurance.
In [50]: Caravan = load_data('Caravan ')
Purchase = Caravan.Purchase
Purchase.value_counts ()
Out[50]: No
5474
Yes
348
Name: Purchase , dtype: int64

The method value_counts() takes a pd.Series or pd.DataFrame and returns a pd.Series with the corresponding counts for each unique element.
In this case Purchase has only Yes and No values and returns how many
values of each there are.

4.7 Lab: Logistic Regression, LDA, QDA, and KNN

185

In [51]: 348 / 5822
Out[51]: 0.0598

Our features will include all columns except Purchase.
In [52]: feature_df = Caravan.drop(columns =['Purchase '])

Because the KNN classifier predicts the class of a given test observation by identifying the observations that are nearest to it, the scale of
the variables matters. Any variables that are on a large scale will have a
much larger effect on the distance between the observations, and hence on
the KNN classifier, than variables that are on a small scale. For instance,
imagine a data set that contains two variables, salary and age (measured
in dollars and years, respectively). As far as KNN is concerned, a difference
of 1,000 USD in salary is enormous compared to a difference of 50 years in
age. Consequently, salary will drive the KNN classification results, and age
will have almost no effect. This is contrary to our intuition that a salary
difference of 1,000 USD is quite small compared to an age difference of 50
years. Furthermore, the importance of scale to the KNN classifier leads to
another issue: if we measured salary in Japanese yen, or if we measured age
in minutes, then we’d get quite different classification results from what we
get if these two variables are measured in dollars and years.
A good way to handle this problem is to standardize the data so that all
standardize
variables are given a mean of zero and a standard deviation of one. Then
all variables will be on a comparable scale. This is accomplished using the
StandardScaler() transformation.
Standard
In [53]: scaler = StandardScaler(with_mean=True ,
with_std=True ,
copy=True)

The argument with_mean indicates whether or not we should subtract the
mean, while with_std indicates whether or not we should scale the columns
to have standard deviation of 1 or not. Finally, the argument copy=True indicates that we will always copy data, rather than trying to do calculations
in place where possible.
This transformation can be fit and then applied to arbitrary data. In the
first line below, the parameters for the scaling are computed and stored
in scaler, while the second line actually constructs the standardized set of
features.
In [54]: scaler.fit(feature_df)
X_std = scaler.transform(feature_df)

Now every column of feature_std below has a standard deviation of one
and a mean of zero.
In [55]: feature_std = pd.DataFrame(
X_std ,
columns=feature_df.columns);
feature_std.std()
Out[55]: MOSTYPE
MAANTHUI

1.000086
1.000086

Scaler()

186

4. Classification

MGEMOMV
MGEMLEEF
MOSHOOFD

1.000086
1.000086
1.000086
...
AZEILPL
1.000086
APLEZIER
1.000086
AFIETS
1.000086
AINBOED
1.000086
ABYSTAND
1.000086
Length: 85, dtype: float64

Notice that the standard deviations are not quite 1 here; this is again due
to some procedures using the 1/n convention for variances (in this case
scaler()), while others use 1/(n − 1) (the std() method). See the footnote
.std()
on page 183. In this case it does not matter, as long as the variables are all
on the same scale.
Using the function train_test_split() we now split the observations into train_test_
a test set, containing 1000 observations, and a training set containing the split()
remaining observations. The argument random_state=0 ensures that we get
the same split each time we rerun the code.
In [56]: (X_train ,
X_test ,
y_train ,
y_test) = train_test_split(feature_std ,
Purchase ,
test_size =1000 ,
random_state =0)

?train_test_split reveals that the non-keyword arguments can be lists,
arrays, pandas dataframes etc that all have the same length (shape[0]) and
hence are indexable. In this case they are the dataframe feature_std and
indexable
the response variable Purchase. We fit a KNN model on the training data

using K = 1, and evaluate its performance on the test data.

In [57]: knn1 = KNeighborsClassifier (n_neighbors =1)
knn1_pred = knn1.fit(X_train , y_train).predict(X_test)
np.mean(y_test != knn1_pred), np.mean(y_test != "No")
Out[57]: (0.111 , 0.067)

The KNN error rate on the 1,000 test observations is about 11%. At first
glance, this may appear to be fairly good. However, since just over 6% of
customers purchased insurance, we could get the error rate down to almost
6% by always predicting No regardless of the values of the predictors! This
is known as the null rate.
null rate
Suppose that there is some non-trivial cost to trying to sell insurance
to a given individual. For instance, perhaps a salesperson must visit each
potential customer. If the company tries to sell insurance to a random
selection of customers, then the success rate will be only 6%, which may
be far too low given the costs involved. Instead, the company would like
to try to sell insurance only to customers who are likely to buy it. So the
overall error rate is not of interest. Instead, the fraction of individuals that
are correctly predicted to buy insurance is of interest.
In [58]: confusion_table(knn1_pred , y_test)

4.7 Lab: Logistic Regression, LDA, QDA, and KNN
Out[58]:

Truth
Predicted
No
Yes

No

Yes

880
53

58
9

187

It turns out that KNN with K = 1 does far better than random guessing
among the customers that are predicted to buy insurance. Among 62 such
customers, 9, or 14.5%, actually do purchase insurance. This is double the
rate that one would obtain from random guessing.
In [59]: 9/(53+9)
Out[59]: 0.145

Tuning Parameters
The number of neighbors in KNN is referred to as a tuning parameter, also
tuning
referred to as a hyperparameter. We do not know a priori what value to parameter
use. It is therefore of interest to see how the classifier performs on test hyperdata as we vary these parameters. This can be achieved with a for loop, parameter
described in Section 2.3.8. Here we use a for loop to look at the accuracy of
our classifier in the group predicted to purchase insurance as we vary the
number of neighbors from 1 to 5:
In [60]: for K in range (1,6):
knn = KNeighborsClassifier (n_neighbors=K)
knn_pred = knn.fit(X_train , y_train).predict(X_test)
C = confusion_table(knn_pred , y_test)
templ = ('K={0:d}: # predicted to rent: {1:>2},' +
' # who did rent {2:d}, accuracy {3:.1%} ')
pred = C.loc['Yes'].sum()
did_rent = C.loc['Yes','Yes']
print(templ.format(
K,
pred ,
did_rent ,
did_rent / pred))
K=1: # predicted
K=2: # predicted
K=3: # predicted
K=4: # predicted
K=5: # predicted

to
to
to
to
to

rent: 62,# who did rent 9, accuracy 14.5%
rent: 6,# who did rent 1, accuracy 16.7%
rent: 20,# who did rent 3, accuracy 15.0%
rent: 3,# who did rent 0, accuracy 0.0%
rent: 7,# who did rent 1, accuracy 14.3%

We see some variability — the numbers for K=4 are very different from the
rest.
Comparison to Logistic Regression
As a comparison, we can also fit a logistic regression model to the data.
This can also be done with sklearn, though by default it fits something
like the ridge regression version of logistic regression, which we introduce
in Chapter 6. This can be modified by appropriately setting the argument
C below. Its default value is 1 but by setting it to a very large number,
the algorithm converges to the same solution as the usual (unregularized)
logistic regression estimator discussed above.

188

4. Classification

Unlike the statsmodels package, sklearn focuses less on inference and
more on classification. Hence, the summary methods seen in statsmodels
and our simplified version seen with summarize are not generally available
for the classifiers in sklearn.
In [61]: logit = LogisticRegression (C=1e10 , solver='liblinear ')
logit.fit(X_train , y_train)
logit_pred = logit.predict_proba(X_test)
logit_labels = np.where(logit_pred [:,1] > 5, 'Yes', 'No')
confusion_table(logit_labels , y_test)
Out[61]:

Truth
Predicted
No
Yes

No

Yes

933
0

67
0

We used the argument solver='liblinear' above to avoid a warning with
the default solver which would indicate that the algorithm does not converge.
If we use 0.5 as the predicted probability cut-off for the classifier, then
we have a problem: none of the test observations are predicted to purchase
insurance. However, we are not required to use a cut-off of 0.5. If we instead
predict a purchase any time the predicted probability of purchase exceeds
0.25, we get much better results: we predict that 29 people will purchase
insurance, and we are correct for about 31% of these people. This is almost
fi